/*
 * (c) Copyright 2005-2011 JAXIO - Generated by Celerio, a Jaxio tool. http://www.jaxio.com
 */
package com.bfds.saec.dao;

import com.bfds.saec.domain.Claimant;
import com.bfds.saec.domain.ClaimantAddress;
import com.bfds.saec.domain.audit.EntityWithAuditVo;
import com.bfds.saec.domain.reference.AddressType;
import com.bfds.saec.util.DataGenerator;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;

import java.util.List;

import static org.junit.Assert.assertTrue;


/**
 * Audit tables are only updated after a transaction is committed. Hence the use of PlatformTransactionManager.
 *
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath*:META-INF/spring/applicationContext-dao-test.xml" })
public class EntityAuditTest {
	@SuppressWarnings("unused")
	private Logger logger = LoggerFactory.getLogger(EntityAuditTest.class);
	
	@Autowired
	private EntityAuditDao auditDao;
	
	@Autowired
	private PlatformTransactionManager transactionManager;

	Claimant claimant;
	
	@Before
	public void before() {
		TransactionTemplate tt = new TransactionTemplate(transactionManager);
		claimant = tt.execute(new TransactionCallback<Claimant>() {
			@Override
			public Claimant doInTransaction(TransactionStatus status) {
				Claimant claimant = DataGenerator.newClaimant(
						"Margarita",
						"Barrington",
						"100001",
						"200001",
						"30001",
						"400001",
						"50001",
						"60001",
						false,
						null,
						null, null,
						null);
				claimant.setAddressOfRecord(DataGenerator.newAddress(AddressType.ADDRESS_OF_RECORD, "2397 Bee Street",
						"Muskegon", "MI", "49470"));
				claimant.persist();
				claimant.flush();
				claimant.clear();
				claimant = Claimant.findClaimant(claimant.getId());

				claimant.getAddressOfRecord().setAddress1("11111111");
				Claimant.save(claimant);
				claimant.flush();
				claimant.clear();
				return claimant;
			}
		});
		
	}
	
	@After
	public void after() {
		final Claimant claimant = this.claimant;
		TransactionTemplate tt = new TransactionTemplate(transactionManager);
		tt.execute(new TransactionCallback<Object>() {
			@Override
			public Object doInTransaction(TransactionStatus status) {
				Claimant c = Claimant.findClaimant(claimant.getId());
				c.remove();
				c.flush();
				c.clear();
				return c;
			}
		});
	}
	
	@Test
	public void createVersionedAddress() {
		final Claimant claimant = this.claimant;
		TransactionTemplate tt = new TransactionTemplate(transactionManager);
		List<EntityWithAuditVo<ClaimantAddress>> versionList = tt.execute(new TransactionCallback<List<EntityWithAuditVo<ClaimantAddress>>>() {
			@Override
			public List<EntityWithAuditVo<ClaimantAddress>> doInTransaction(TransactionStatus status) {
				return auditDao.getEntityVersionList(ClaimantAddress.class, claimant.getAddressOfRecord().getId());
			}
		});
		
		assertTrue(versionList != null);
	}
}